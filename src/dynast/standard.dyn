def u32:unsigned 32
def s32:signed 32
def u64:unsigned 64
def s64:signed 64
def f32:float 32
def f64:float 64

# Coersion casts
export func inline : (i:s64):s32 asm = i s32.wrap/s64;
export func inline : (i:f32):s32 asm = i s32.trunc_s/f32;
export func inline : (i:f64):s32 asm = i s32.trunc_s/f64;
export func inline : (i:s32):s64 asm = i s64.extend_s/s32;
export func inline : (i:f32):s64 asm = i s64.trunc_s/f32;
export func inline : (i:f64):s64 asm = i s64.trunc_s/f64;
export func inline : (i:s32):f32 asm = i f32.convert_s/s32;
export func inline : (i:s64):f32 asm = i f32.convert_s/s64;
export func inline : (i:f64):f32 asm = i f32.demote/f64;
export func inline : (i:s32):f64 asm = i f64.convert_s/s32;
export func inline : (i:s64):f64 asm = i f64.convert_s/s64;
export func inline : (i:f32):f64 asm = i f64.promote/f32;

export func inline : (i:u64):u32 asm = i u32.wrap/u64;
export func inline : (i:f32):u32 asm = i u32.trunc_u/f32;
export func inline : (i:f64):u32 asm = i u32.trunc_u/f64;
export func inline : (i:u32):u64 asm = i u64.extend_u/u32;
export func inline : (i:f32):u64 asm = i u64.trunc_u/f32;
export func inline : (i:f64):u64 asm = i u64.trunc_u/f64;
export func inline : (i:u32):f32 asm = i f32.convert_u/u32;
export func inline : (i:u64):f32 asm = i f32.convert_u/u64;
export func inline : (i:f64):f32 asm = i f32.demote/f64;
export func inline : (i:u32):f64 asm = i f64.convert_u/u32;
export func inline : (i:u64):f64 asm = i f64.convert_u/u64;
export func inline : (i:f32):f64 asm = i f64.promote/f32;

# Re-interpreting casts
export func inline ~ (i:f32):s32 asm = i s32.reinterpret/f32;
export func inline ~ (i:f64):s64 asm = i s64.reinterpret/f64;
export func inline ~ (i:s32):f32 asm = i f32.reinterpret/s32;
export func inline ~ (i:s64):f64 asm = i f64.reinterpret/s64;

export func inline ~ (i:f32):u32 asm = i u32.reinterpret/f32;
export func inline ~ (i:f64):u64 asm = i u64.reinterpret/f64;
export func inline ~ (i:u32):f32 asm = i f32.reinterpret/u32;
export func inline ~ (i:u64):f64 asm = i f64.reinterpret/u64;

# 32-bit integer ops
export func inline == (a:s32, b:s32):s32 asm = a, b i32.eq;
export func inline != (a:s32, b:s32):s32 asm = a, b i32.ne;
export func inline < (a:s32, b:s32):s32 asm = a, b i32.lt_s;
export func inline > (a:s32, b:s32):s32 asm = a, b i32.gt_s;
export func inline <= (a:s32, b:s32):s32 asm = a, b i32.le_s;
export func inline >= (a:s32, b:s32):s32 asm = a, b i32.ge_s;
export func inline + (a:s32, b:s32):s32 asm = a, b i32.add;
export func inline - (a:s32, b:s32):s32 asm = a, b i32.sub;
export func inline * (a:s32, b:s32):s32 asm = a, b i32.mul;
export func inline / (a:s32, b:s32):s32 asm = a, b i32.div_s;
export func inline % (a:s32, b:s32):s32 asm = a, b i32.rem_s;
export func inline & (a:s32, b:s32):s32 asm = a, b i32.and;
export func inline | (a:s32, b:s32):s32 asm = a, b i32.or;
export func inline ^ (a:s32, b:s32):s32 asm = a, b i32.xor;
export func inline << (a:s32, b:s32):s32 asm = a, b i32.shl;
export func inline >> (a:s32, b:s32):s32 asm = a, b i32.shr_s;
export func inline <<< (a:s32, b:s32):s32 asm = a, b i32.rotl;
export func inline >>> (a:s32, b:s32):s32 asm = a, b i32.rotr;

export func inline eqz(i:s32):s32 asm = i i32.eqz;
export func inline clz(i:s32):s32 asm = i i32.clz;
export func inline ctz(i:s32):s32 asm = i i32.ctz;
export func inline popcnt(i:s32):s32 asm = i i32.popcnt;

export func inline == (a:u32, b:u32):u32 asm = a, b i32.eq;
export func inline != (a:u32, b:u32):u32 asm = a, b i32.ne;
export func inline < (a:u32, b:u32):u32 asm = a, b i32.lt_u;
export func inline > (a:u32, b:u32):u32 asm = a, b i32.gt_u;
export func inline <= (a:u32, b:u32):u32 asm = a, b i32.le_u;
export func inline >= (a:u32, b:u32):u32 asm = a, b i32.ge_u;
export func inline + (a:u32, b:u32):u32 asm = a, b i32.add;
export func inline - (a:u32, b:u32):u32 asm = a, b i32.sub;
export func inline * (a:u32, b:u32):u32 asm = a, b i32.mul;
export func inline / (a:u32, b:u32):u32 asm = a, b i32.div_u;
export func inline % (a:u32, b:u32):u32 asm = a, b i32.rem_u;
export func inline & (a:u32, b:u32):u32 asm = a, b i32.and;
export func inline | (a:u32, b:u32):u32 asm = a, b i32.or;
export func inline ^ (a:u32, b:u32):u32 asm = a, b i32.xor;
export func inline << (a:u32, b:u32):u32 asm = a, b i32.shl;
export func inline >> (a:u32, b:u32):u32 asm = a, b i32.shr_u;
export func inline <<< (a:u32, b:u32):u32 asm = a, b i32.rotl;
export func inline >>> (a:u32, b:u32):u32 asm = a, b i32.rotr;

export func inline eqz(i:u32):u32 asm = i i32.eqz;
export func inline clz(i:u32):u32 asm = i i32.clz;
export func inline ctz(i:u32):u32 asm = i i32.ctz;
export func inline popcnt(i:u32):u32 asm = i i32.popcnt;

# 64-bit integer ops
export func inline == (a:s64, b:s64):s64 asm = a, b i64.eq;
export func inline != (a:s64, b:s64):s64 asm = a, b i64.ne;
export func inline < (a:s64, b:s64):s64 asm = a, b i64.lt_s;
export func inline > (a:s64, b:s64):s64 asm = a, b i64.gt_s;
export func inline <= (a:s64, b:s64):s64 asm = a, b i64.le_s;
export func inline >= (a:s64, b:s64):s64 asm = a, b i64.ge_s;
export func inline + (a:s64, b:s64):s64 asm = a, b i64.add;
export func inline - (a:s64, b:s64):s64 asm = a, b i64.sub;
export func inline * (a:s64, b:s64):s64 asm = a, b i64.mul;
export func inline / (a:s64, b:s64):s64 asm = a, b i64.div_s;
export func inline % (a:s64, b:s64):s64 asm = a, b i64.rem_s;
export func inline & (a:s64, b:s64):s64 asm = a, b i64.and;
export func inline | (a:s64, b:s64):s64 asm = a, b i64.or;
export func inline ^ (a:s64, b:s64):s64 asm = a, b i64.xor;
export func inline << (a:s64, b:s64):s64 asm = a, b i64.shl;
export func inline >> (a:s64, b:s64):s64 asm = a, b i64.shr_s;
export func inline <<< (a:s64, b:s64):s64 asm = a, b i64.rotl;
export func inline >>> (a:s64, b:s64):s64 asm = a, b i64.rotr;

export func inline eqz (i:s64):s64 asm = i i64.eqz;
export func inline clz (i:s64):s64 asm = i i64.clz;
export func inline ctz (i:s64):s64 asm = i i64.ctz;
export func inline popcnt (i:s64):s64 asm = i i64.popcnt;

export func inline == (a:u64, b:u64):u64 asm = a, b i64.eq;
export func inline != (a:u64, b:u64):u64 asm = a, b i64.ne;
export func inline < (a:u64, b:u64):u64 asm = a, b i64.lt_u;
export func inline > (a:u64, b:u64):u64 asm = a, b i64.gt_u;
export func inline <= (a:u64, b:u64):u64 asm = a, b i64.le_u;
export func inline >= (a:u64, b:u64):u64 asm = a, b i64.ge_u;
export func inline + (a:u64, b:u64):u64 asm = a, b i64.add;
export func inline - (a:u64, b:u64):u64 asm = a, b i64.sub;
export func inline * (a:u64, b:u64):u64 asm = a, b i64.mul;
export func inline / (a:u64, b:u64):u64 asm = a, b i64.div_u;
export func inline % (a:u64, b:u64):u64 asm = a, b i64.rem_u;
export func inline & (a:u64, b:u64):u64 asm = a, b i64.and;
export func inline | (a:u64, b:u64):u64 asm = a, b i64.or;
export func inline ^ (a:u64, b:u64):u64 asm = a, b i64.xor;
export func inline << (a:u64, b:u64):u64 asm = a, b i64.shl;
export func inline >> (a:u64, b:u64):u64 asm = a, b i64.shr_u;
export func inline <<< (a:u64, b:u64):u64 asm = a, b i64.rotl;
export func inline >>> (a:u64, b:u64):u64 asm = a, b i64.rotr;

export func inline eqz (i:u64):u64 asm = i i64.eqz;
export func inline clz (i:u64):u64 asm = i i64.clz;
export func inline ctz (i:u64):u64 asm = i i64.ctz;
export func inline popcnt (i:u64):u64 asm = i i64.popcnt;

# 32-bit Floating point operations
export func inline == (a:f32, b:f32):f32 asm = a, b f32.eq;
export func inline != (a:f32, b:f32):f32 asm = a, b f32.ne;
export func inline < (a:f32, b:f32):f32 asm = a, b f32.lt;
export func inline > (a:f32, b:f32):f32 asm = a, b f32.gt;
export func inline <= (a:f32, b:f32):f32 asm = a, b f32.le;
export func inline >= (a:f32, b:f32):f32 asm = a, b f32.ge;
export func inline + (a:f32, b:f32):f32 asm = a, b f32.add;
export func inline - (a:f32, b:f32):f32 asm = a, b f32.sub;
export func inline * (a:f32, b:f32):f32 asm = a, b f32.mul;
export func inline / (a:f32, b:f32):f32 asm = a, b f32.div;
export func inline min (a:f32, b:f32):f32 asm = a, b f32.min;
export func inline max (a:f32, b:f32):f32 asm = a, b f32.max;
export func inline copysign (a:f32, b:f32):f32 asm = a, b f32.copysign;

export func inline abs (i:f32):f32 asm = i f32.abs;
export func inline neg (i:f32):f32 asm = i f32.neg;
export func inline ceil (i:f32):f32 asm = i f32.ceil;
export func inline floor (i:f32):f32 asm = i f32.floor;
export func inline trunc (i:f32):f32 asm = i f32.trunc;
export func inline nearest (i:f32):f32 asm = i f32.nearest;
export func inline sqrt (i:f32):f32 asm = i f32.sqrt;

# 64-bit floating point operations
export func inline == (a:f64, b:f64):f64 asm = a, b f64.eq;
export func inline != (a:f64, b:f64):f64 asm = a, b f64.ne;
export func inline < (a:f64, b:f64):f64 asm = a, b f64.lt;
export func inline > (a:f64, b:f64):f64 asm = a, b f64.gt;
export func inline <= (a:f64, b:f64):f64 asm = a, b f64.le;
export func inline >= (a:f64, b:f64):f64 asm = a, b f64.ge;
export func inline + (a:f64, b:f64):f64 asm = a, b f64.add;
export func inline - (a:f64, b:f64):f64 asm = a, b f64.sub;
export func inline * (a:f64, b:f64):f64 asm = a, b f64.mul;
export func inline / (a:f64, b:f64):f64 asm = a, b f64.div;
export func inline min (a:f64, b:f64):f64 asm = a, b f64.min;
export func inline max (a:f64, b:f64):f64 asm = a, b f64.max;
export func inline copysign (a:f64, b:f64):f64 asm = a, b f64.copysign;

export func inline abs (i:f64):f64 asm = i f64.abs;
export func inline neg (i:f64):f64 asm = i f64.neg;
export func inline ceil (i:f64):f64 asm = i f64.ceil;
export func inline floor (i:f64):f64 asm = i f64.floor;
export func inline trunc (i:f64):f64 asm = i f64.trunc;
export func inline nearest (i:f64):f64 asm = i f64.nearest;
export func inline sqrt (i:f64):f64 asm = i f64.sqrt;

#/ Currently unmapped opcodes
i32.const
i32.load
i32.load8_s
i32.load8_u
i32.load16_s
i32.load16_u
i32.store
i32.store8
i32.store16

i64.const
i64.load
i64.load8_s
i64.load8_u
i64.load16_s
i64.load16_u
i64.load32_s
i64.load32_u
i64.store
i64.store8
i64.store16
i64.store32

f32.const
f32.load
f32.store

f64.const
f64.load
f64.store
/#

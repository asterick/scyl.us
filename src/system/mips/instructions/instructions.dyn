import memory static_memory

const AddressLoad:u32 		  	= 0x04
const AddressStore:u32 		  	= 0x05
const SysCall:u32 			  	= 0x08
const Breakpoint:u32 		  	= 0x09
const ReservedInstruction:u32 	= 0x0A
const CoprocessorUnusable:u32 	= 0x0B
const Overflow:u32 			  	= 0x0C

def registers:[32]u32
def pc:u32 = 0xBCF00000
def lo:u32
def hi:u32

#######
## Helper stuff
#######

import func delay(u32)
import func exception(u32, u32, u32, u32)

func reg(index:u32):u32 {
	return if index > 0 then registers[index] else 0
}

########
## Load/Store instructions
########

import func load(u32, u32, u32)
import func store(u32, u32, u32, u32, u32)

export func LB(rt:u32, rs:u32, imm16:u32, address:u32, delayed:u32) {
	def target:u32 = reg(rs) + imm16
	def value:u32 = load(target, address, delayed)

	registers[rt] = value << (24 - 8 * (target & 3)) >> 24
}

export func LBU(rt:u32, rs:u32, imm16:u32, address:u32, delayed:u32) {
	def target:u32 = reg(rs) + imm16
	def value:u32 = load(target, address, delayed)

	registers[rt] = (v >> (8 * (target & 3))) & 0xFF
}

export func LH(rt:u32, rs:u32, imm16:u32, address:u32, delayed:u32) {
	def target:u32 = reg(rs) + imm16

	if (target & 1) then exception(AddressLoad, address, delayed)

	def value:u32 = load(target, address, delayed)

	registers[rt] = if (target & 2) then (value:s32 >> 16) else (value:s32 << 16 >> 16):u32
}

export func LHU(rt:u32, rs:u32, imm16:u32, address:u32, delayed:u32) {
	def target:u32 = reg(rs) + imm16

	if (target & 1) then exception(AddressLoad, address, delayed)

	def value:u32 = load(target, address, delayed)

	registers[rt] = if target & 2 then (value >> 16) else (value & 0xFFFF)
}

export func LW(rt:u32, rs:u32, imm16:u32, address:u32, delayed:u32) {
	def target:u32 = reg(rs) + imm16

	if (target & 3) then exception(AddressLoad, address, delayed)

	registers[rt] = load(target, address, delayed)
}

export func SB(rt:u32, rs:u32, imm16:u32, address:u32, delayed:u32) {
	def target:u32 = reg(rs) + imm16

	store(target, reg(rt) << (target & 3), 0xFF << (8 * (target & 3)), address, delayed)
}

export func SH(rt:u32, rs:u32, imm16:u32, address:u32, delayed:u32) {
	def target:u32 = reg(rs) + imm16

	if (target & 1) then exception(AddressStore, address, delayed)

	store(target, reg(rt) << (target & 2), 0xFFFF << (8 * (target & 3)), address, delayed)
}

export func SW(rt:u32, rs:u32, imm16:u32, address:u32, delayed:u32) {
	def target:u32 = reg(rs) + imm16

	if (target & 3) then exception(AddressStore, address, delayed)

	store(target, reg(rt), 0xFFFFFFFF, address, delayed)
}

export func LWR(rt:u32, rs:u32, imm16:u32, address:u32, delayed:u32) {
	def target:u32 = reg(rs) + imm16
	var value = load(target, address, delayed)
	var bit = 8 * (target & 3)

	registers[rt] = registers[rt] & (0xFFFFFFFF << (32 - bit)) | (value >> bit)
}

export func LWL(rt:u32, rs:u32, imm16:u32, address:u32, delayed:u32) {
	def target:u32 = reg(rs) + imm16
	def value:u32 = load(target, address, delayed)

	if ((0xFFFFFFFF ^ target) & 3) then {
		def bit:u32 = 8 * (target & 3) + 8

		registers[rt] = (registers[rt] & (0xFFFFFFFF >> bit)) | (value << (32 - bit))
	}
}

export func SWR(rt:u32, rs:u32, imm16:u32, address:u32, delayed:u32) {
	def target:u32 = reg(rs) + imm16
	def bit:u32 = 8 * (target & 3)

	store(target, reg(rt), 0xFFFFFFFF << bit, address, delayed)
}

export func SWL(rt:u32, rs:u32, imm16:u32, address:u32, delayed:u32) {
	def target:u32 = reg(rs) + imm16

	if ((0xFFFFFFFF ^ target) & 3) then {
		def bit:u32 = 8 * (target & 3) + 8
		store(target, reg(rt) >> (32 - bit), 0xFFFFFFFF >> (32 - bit), address, delayed)
	}
}

########
## Arithmatic instructions
########

export func ADD(rd:u32, rs:u32, rt:u32, address:u32, delayed:u32) {
	def value:s64 = (reg(rs):s32):s64 + (reg(rt):s32):s64

	if (value < -0x80000000) then {
		exception(Overflow, address, delayed, 0)
	} else if (value >= 0x80000000) then {
		exception(Overflow, address, delayed, 0)
	}

	registers[rd] = value:u32
}

export func ADDU(rd:u32, rs:u32, rt:u32) {
	registers[rd] = reg(rs) + reg(rt)
}

export func SUB(rd:u32, rs:u32, rt:u32, address:u32, delayed:u32) {
	def value:s64 = (reg(rs):s32):s64 - (reg(rt):s32):s64

	if (value < -0x80000000) then {
		exception(Overflow, address, delayed, 0)
	} else if (value >= 0x80000000) then {
		exception(Overflow, address, delayed, 0)
	}

	registers[rd] = value:u32
}

export func SUBU(rd:u32, rs:u32, rt:u32) {
	registers[rd] = reg(rs) - reg(rt)
}

export func ADDI(rt:u32, rs:u32, simm16:s32, address:u32, delayed:u32) {
	def value:s64 = (reg(rs):s32):s64 + simm16:s64

	if (value < -0x80000000) then {
		exception(Overflow, address, delayed, 0)
	} else if (value >= 0x80000000) then {
		exception(Overflow, address, delayed, 0)
	}

	registers[rt] = value:u32
}

export func ADDIU(rt:u32, rs:u32, simm16:s32) {
	registers[rt] = (reg(rs):s32 + simm16):u32
}

########
## Comparison instructions
########

export func SLT(rd:u32, rs:u32, rt:u32) {
	registers[rd] = reg(rs):s32 < reg(rt):s32
}

export func SLTU(rd:u32, rs:u32, rt:u32) {
	registers[rd] = reg(rs) < reg(rt)
}

export func SLTI(rt:u32, rs:u32, simm16:s32) {
	registers[rt] = reg(rs):s32 < simm16
}

export func SLTIU(rt:u32, rs:u32, simm16:s32) {
	registers[rt] = reg(rs) < simm16:u32
}

########
## Logical instructions
########

export func AND(rd:u32, rs:u32, rt:u32) {
	registers[rd] = reg(rt) & reg(rs)
}

export func OR(rd:u32, rs:u32, rt:u32) {
	registers[rd] = reg(rt) | reg(rs)
}

export func XOR(rd:u32, rs:u32, rt:u32) {
	registers[rd] = reg(rt) ^ reg(rs)
}

export func NOR(rd:u32, rs:u32, rt:u32) {
	registers[rd] = 0xFFFFFFFF ^ (reg(rt) | reg(rs))
}

export func ANDI(rt:u32, rs:u32, imm16:u32) {
	registers[rt] = reg(rs) & imm16
}

export func ORI(rt:u32, rs:u32, imm16:u32) {
	registers[rt] = reg(rs) | imm16
}

export func XORI(rt:u32, rs:u32, imm16:u32) {
	registers[rt] = reg(rs) ^ imm16
}

########
## Shift instructions
########

export func SLLV(rd:u32, rt:u32, rs:u32) {
	registers[rd] = reg(rt) << (reg(rs) & 0x1F)
}

export func SRLV(rd:u32, rt:u32, rs:u32) {
	registers[rd] = reg(rt) >> (reg(rs) & 0x1F)
}

export func SRAV(rd:u32, rt:u32, rs:u32) {
	registers[rd] = reg(rt):s32 >> (reg(rs) & 0x1F)
}

export func SLL(rd:u32, rt:u32, shamt:u32) {
	registers[rd] = reg(rt) << shamt
}

export func SRL(rd:u32, rt:u32, shamt:u32) {
	registers[rd] = reg(rt) >> shamt
}

export func SRA(rd:u32, rt:u32, shamt:u32) {
	registers[rd] = reg(rt):s32 >> shamt
}

export func LUI(rt:u32, imm16:u32) {
	registers[rt] = imm16 << 16
}

########
## Multiply/Divide instructions
########

export func MULT(rs:u32, rt:u32) {
	def res:s64 = reg(rs):s64 * reg(rt):s64

	hi = (res >> 32):u32
	lo = res:u32
}

export func MULTU(rs:u32, rt:u32) {
	def res:u64 = reg(rs):u64 * reg(rt):u64

	hi = (res >> 32):u32
	lo = res:u32
}

export func DIV(rs:u32, rt:u32) {
	def s:s32 = reg(rs):s32
	def t:s32 = reg(rt):s32

	if (s == -0x80000000 && t == -1) then {
		hi = 0x80000000
		lo = 0
	} else if (t == 0) then {
		hi = s
		lo = if (s < 0) then 1 else -1
	} else {
		hi = s % t
		lo = s / t
	}
}

export func DIVU(rs:u32, rt:u32) {
	def s:u32 = reg(rs)
	def t:u32 = reg(rt)

	if (t == 0) then {
		hi = s
		lo = 0
	} else {
		hi = s % t
		lo = s / t
	}
}

export func MFHI(rd:u32) {
	registers[rd] = hi
}

export func MFLO(rd:u32) {
	registers[rd] = lo
}

export func MTHI(rs:u32) {
	hi = reg(rs)
}

export func MTLO(rs:u32) {
	lo = reg(rs)
}

########
## Branching instructions
########

export func J (address:u32, imm26:u32) {
	pc = (address & 0xF0000000) | (imm26 * 4)
	delay(address + 4)
}

export func JAL (address:u32, imm26:u32) {
	registers[31] = address + 8
	pc = (address & 0xF0000000) | (imm26 * 4)
	delay(address + 4)
}

export func JR(rs:u32, address:u32) {
	pc = reg(rs) & 0xFFFFFFFC
	delay(address + 4)
}

export func JALR(rs:u32, rd:u32, address:u32) {
	registers[rd] = address + 8
	pc = reg(rs):s32 & 0xFFFFFFFC
	delay(address + 4)
}

export func BEQ(address:u32, rs:u32, rt:u32, simm16:s32) {
	if (reg(rs):s32 == reg(rt):s32) then {
		pc = (address + 4) + (simm16 * 4)
		delay(address + 4)
	}
}

export func BNE(address:u32, rs:u32, rt:u32, simm16:s32) {
	if (reg(rs):s32 != reg(rt):s32) then {
		pc = (address + 4) + (simm16 * 4)
		delay(address + 4)
	}
}

export func BLTZ(address:u32, rs:u32, simm16:s32) {
	if (reg(rs):s32 < 0) then  {
		pc = (address + 4) + (simm16 * 4)
		delay(address + 4)
	}
}

export func BGEZ(address:u32, rs:u32, simm16:s32) {
	if (reg(rs):s32 >= 0) then {
		pc = (address + 4) + (simm16 * 4)
		delay(address + 4)
	}
}

export func BGTZ(address:u32, rs:u32, simm16:s32) {
	if (reg(rs):s32 > 0) then  {
		pc = (address + 4) + (simm16 * 4)
		delay(address + 4)
	}
}

export func BLEZ(address:u32, rs:u32, simm16:s32) {
	if (reg(rs):s32 <= 0) then {
		pc = (address + 4) + (simm16 * 4)
		delay(address + 4)
	}
}

export func BLTZAL(address:u32, rs:u32, simm16:s32) {
	if (reg(rs):s32 < 0) then {
		registers[31] = address + 8
		pc = (address + 4) + (simm16 * 4)
		delay(address + 4)
	}
}

export func BGEZAL(address:u32, rs:u32, simm16:s32) {
	if (reg(rs):s32 >= 0) then {
		registers[31] = address + 8
		pc = (address + 4) + (simm16 * 4)
		delay(address + 4)
	}
}

#######
## Co-Processor Move registers
#######

import func mfc0(u32, u32, u32)
import func mtc0(u32, u32, u32, u32)

export func MFC0(rt:u32, rd:u32, address:u32, delayed:u32) {
	registers[rt] = mfc0(rd, address, delayed)
}

export func MTC0(rt:u32, rd:u32, address:u32, delayed:u32) {
	mtc0(rd, reg(rt), address, delayed)
}

#######
## Co-Processor instructions
#######

import func rfe(u32, u32)
import func tlbr(u32, u32)
import func tlbwi(u32, u32)
import func tlbwr(u32, u32)
import func tlbp(u32, u32)

export func RFE(address:u32, delayed:u32) {
	rfe(address, delayed)
}

export func TLBR(address:u32, delayed:u32) {
	tlbr(address, delayed)
}

export func TLBWI(address:u32, delayed:u32) {
	tlbwi(address, delayed)
}

export func TLBWR(address:u32, delayed:u32) {
	tlbwr(address, delayed)
}

export func TLBP(address:u32, delayed:u32) {
	tlbp(address, delayed)
}

#####
## Exception generators
#####

export func SYSCALL(address:u32, delayed:u32) {
	exception(SysCall, address, delayed, 0)
}

export func BREAK(address:u32, delayed:u32) {
	exception(Breakpoint, address, delayed, 0)
}

export func ReservedInstruction(address:u32, delayed:u32) {
	exception(ReservedInstruction, address, delayed, 0)
}

export func CopUnusable(address:u32, delayed:u32, cop:u32) {
	exception(CoprocessorUnusable, address, delayed, cop)
}
